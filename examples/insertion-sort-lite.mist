struct SeqInt {}
struct MultisetInt {}
pure fn len(xs: SeqInt) -> int;
pure fn union(a: MultisetInt, b: MultisetInt) -> MultisetInt;

pure fn sorted(xs: SeqInt) -> bool {
    if len(xs) <= 1 {
        true
    } else {
        xs[0] <= xs[1] && sorted(xs[1..])
    }
}

// sanity check
ghost fn lemma_total_order(xs: SeqInt, i: int, j: int)
    requires sorted(xs),
          0 <= i, i <= j, j < len(xs)
    ensures xs[i] <= xs[j]
    // decreases i + j
{
    let v = i + j;
    assert v >= 0;
    if i != 0 {
        assert i-1 + j - 1 < v;
        lemma_total_order(xs[1..], i-1, j-1)
    // } else if i != j {
    } else {
        assert 0 + j - 1 < v;
        lemma_total_order(xs[1..], 0, j-1)
    }
}

pure fn to_multiset(xs: SeqInt) -> MultisetInt {
    if len(xs) == 0 {
        Multiset()
    } else {
        union(Multiset(xs[0]), to_multiset(xs))
    }
}

pure fn same_elements(xs: SeqInt, ys: SeqInt) -> bool {
    to_multiset(xs) == to_multiset(ys)
}

fn insertion_sort(xs: SeqInt) -> SeqInt
    ensures sorted(result),
            len(result) == len(xs),
            same_elements(xs, result)
    // decreases len(xs)
{
    let v = len(xs);
    assert v >= 0;
    if len(xs) == 0 {
        Seq()
    } else {
        assert len(xs[1..]) < len(xs)
        insert(xs[0], insertion_sort(xs[1..]))
    }
}



fn insert(x: int, xs: SeqInt) -> SeqInt
    requires sorted(xs)
    ensures sorted(result),
            len(result) == len(xs) + 1,
            if len(xs) == 0 { result[0] == x } else { result[0] == x || result[0] == xs[0] },
            same_elements(Seq(x) ++ xs, result)
    // decreases len(xs)
{
    let v = len(xs);
    assert v >= 0;
    if len(xs) == 0 {
        Seq(x)
    } else {
        let y = xs[0];
        if x < y {
            lemma_insert_smallest(x, xs);
            Seq(x) ++ xs
        } else {
            assert len(xs[1..]) < v;
            let res = insert(x, xs[1..]);
            lemma_insert_smallest(y, res);
            Seq(y) ++ res
        }
    }
}

fn lemma_insert_smallest(x: int, xs: SeqInt)
    requires sorted(xs), if len(xs) > 0 { x <= xs[0] } else { true }
    ensures sorted(Seq(x) ++ xs)
{
    if len(xs) > 0 {
        let ys = Seq(x) ++ xs;
        assert xs == ys[1..]; // triggering ground term
    }
}
