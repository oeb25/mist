pure fn sorted(xs: Seq[int]) -> bool {
    if |xs| <= 1 {
        true
    } else {
        xs[0] <= xs[1] && sorted(xs[1..])
    }
}

// sanity check
ghost fn lemma_total_order(xs: Seq[int], i: int, j: int)
    where sorted(xs),
          0 <= i, i <= j, j < |xs|
    ensures xs[i] <= xs[j]
    // decreases i + j
{
    let v = i + j;
    assert v >= 0;
    if i != 0 {
        assert i-1 + j - 1 < v
        lemma_total_order(xs[1..], i-1, j-1)
    } else if i != j {
        assert 0 + j - 1 < v
        lemma_total_order(xs[1..], 0, j-1)
    }
}

pure fn to_multiset(xs: Seq[int]) -> Multiset[int] {
    if |xs| == 0 {
        Multiset()
    } else {
        union(Multiset(xs[0]), to_multiset(xs))
    }
}

pure fn same_elements(xs: Seq[int], ys: Seq[int]) -> bool {
    to_multiset(xs) == to_multiset(ys)
}

fn insertion_sort(xs: Seq[int]) -> Seq[int]
    ensures sorted(result),
            |result| == |xs|,
            same_elements(xs, result)
    // decreases |xs|
{
    let v := |xs|;
    assert v >= 0;
    if |xs| == 0 {
        Seq()
    } else {
        assert |xs[1..]| < |xs|
        insert(xs[0], insertion_sort(xs[1..]))
    }
}



fn insert(x: int, xs: Seq[int]) -> Seq[int]
    where sorted(xs)
    ensures sorted(result),
            |result| == |xs| + 1,
            if |xs| == 0 { result[0] == x } else { result[0] == x || result[0] == xs[0] },
            same_elements(Seq(x) ++ xs, result)
    // decreases |xs|
{
    let v = |xs|;
    assert v >= 0;
    if |xs| == 0 {
        Seq(x)
    } else {
        let y = xs[0];
        if x < y {
            lemma_insert_smallest(x, xs);
            Seq(x) ++ xs
        } else {
            assert |xs[1..]| < v;
            let res = insert(x, xs[1..]);
            lemma_insert_smallest(y, res);
            Seq(y) ++ res
        }
    }
}

fn lemma_insert_smallest(x: int, xs: Seq[int])
    where sorted(xs), if |xs| > 0 { x <= xs[0] }
    ensures sorted(Seq(x) ++ xs)
{
    if |xs| > 0 {
        let ys = Seq(x) ++ xs;
        assert xs == ys[1..]; // triggering ground term
    }
}
