pure fn sorted(xs: [int]) -> bool
    dec xs.len
{
    if xs.len <= 1 {
        true
    } else {
        xs[0] <= xs[1] && sorted(xs[1..])
    }
}

// sanity check
ghost fn lemma_total_order(xs: [int], i: int, j: int)
    req sorted(xs),
        0 <= i, i <= j, j < xs.len
    ens xs[i] <= xs[j]
    dec xs.len
{
    let v = i + j;
    assert v >= 0;
    if i != 0 {
        assert i-1 + j - 1 < v;
        lemma_total_order(xs[1..], i-1, j-1)
    } else if i != j {
        assert 0 + j - 1 < v;
        lemma_total_order(xs[1..], 0, j-1)
    }
}

struct Multiset {
    ghost items: [int]
}

pure ghost fn union(x: Multiset, y: Multiset) -> Multiset;

pure ghost fn to_multiset(xs: [int]) -> Multiset
    dec xs.len
{
    if xs.len == 0 {
        Multiset { items: [] }
    } else {
        union(Multiset { items: [xs[0]] }, to_multiset(xs))
    }
}

pure ghost fn same_elements(xs: [int], ys: [int]) -> bool {
    to_multiset(xs) == to_multiset(ys)
}

fn insertion_sort(xs: [int]) -> [int]
    ens sorted(result),
        result.len == xs.len,
        same_elements(xs, result)
    dec xs.len
{
    let v = xs.len;
    assert v >= 0;
    if xs.len == 0 {
        []
    } else {
        assert xs[1..].len < xs.len;
        insert(xs[0], insertion_sort(xs[1..]))
    }
}



fn insert(x: int, xs: [int]) -> [int]
    req sorted(xs)
    ens sorted(result),
        result.len == xs.len + 1,
        if xs.len == 0 { result[0] == x } else { result[0] == x || result[0] == xs[0] },
        same_elements([x] + xs, result)
    dec xs.len
{
    if xs.len == 0 {
        [x]
    } else {
        let y = xs[0];
        if x < y {
            lemma_insert_smallest(x, xs);
            [x] + xs
        } else {
            let res = insert(x, xs[1..]);
            lemma_insert_smallest(y, res);
            [y] + res
        }
    }
}

ghost fn lemma_insert_smallest(x: int, xs: [int])
    req sorted(xs), if xs.len > 0 { x <= xs[0] } else { true }
    ens sorted([x] + xs)
{
    if xs.len > 0 {
        let ys = [x] + xs;
        assert xs == ys[1..]; // triggering ground term
    }
}
